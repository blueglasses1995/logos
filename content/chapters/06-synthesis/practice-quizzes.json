[
  {
    "id": "ch6-p1",
    "type": "multiple-choice",
    "question": "ビジネスメールで「本プロジェクトは予算超過しており（P）、スケジュールも遅延しています（Q）。したがってプロジェクトを中止すべきです（R）」。この論証の分析として正しいのは？",
    "options": [
      "前提(P∧Q)は明示されているが、P∧Q → R という暗黙の前提が必要。予算超過と遅延があっても、中止が最善とは限らない",
      "モーダスポネンスにより論理的に妥当",
      "偽の二択。中止以外にもオプションがある",
      "前提が真なので健全な論証である"
    ],
    "correctIndex": 0,
    "explanation": "「予算超過かつ遅延」→「中止すべき」という条件文が暗黙の前提です。しかしこの前提は自明ではなく、予算追加、スコープ縮小、スケジュール延長など他の選択肢もあります。暗黙の前提を明示化することが分析の第一歩です。"
  },
  {
    "id": "ch6-p2",
    "type": "multiple-choice",
    "question": "法的文書のレビューで「本規約に同意した場合（P）、すべてのサービスを利用できる（Q）。サービスを利用している（Q）」と確認しました。「規約に同意した（P）」と結論づけてよいですか？",
    "options": [
      "論理的には不十分。P→QとQからPは導けない（後件肯定）。無料トライアルなど別経路の可能性がある",
      "正しい。モーダスポネンスにより導ける",
      "正しい。サービス利用は同意の証拠になる",
      "情報が不足しており判断できない"
    ],
    "correctIndex": 0,
    "explanation": "P → Q（同意→利用可能）と Q（利用している）から P（同意した）を導くのは後件肯定の誤謬です。利用できる経路が同意以外にもある可能性があります。法的判断では、同意の記録を別途確認する必要があります。"
  },
  {
    "id": "ch6-p3",
    "type": "multiple-choice",
    "question": "技術仕様書に「すべてのAPIエンドポイントは認証が必要である（∀x(API(x)→Auth(x))）」と「一部のエンドポイントはレート制限がある（∃x(API(x)∧RateLimit(x))）」の2つの要件があります。「認証なしでアクセスできるエンドポイントにはレート制限がない」と結論づけることはできますか？",
    "options": [
      "できない。最初の要件により認証なしのエンドポイントは存在しないため、その前提自体が空（前件が偽）",
      "できる。認証がなければレート制限もない",
      "できない。情報が不足している",
      "できる。論理的に導ける"
    ],
    "correctIndex": 0,
    "explanation": "∀x(API(x)→Auth(x))により、すべてのAPIエンドポイントは認証が必要です。したがって「認証なしでアクセスできるエンドポイント」は存在しません。存在しないものについて何かを結論づけることは、空真（vacuous truth）です。"
  },
  {
    "id": "ch6-p4",
    "type": "multiple-choice",
    "question": "営業プレゼンで「先日もA社様で30%のコスト削減を達成しました。B社様も同じ業界ですから、同様の成果が見込めます。有名コンサルタントのX氏も当社の手法を推薦しています」。この中の誤謬をすべて選ぶと？",
    "options": [
      "不当な一般化（A社の成果がB社にも当てはまるとは限らない）+ 権威への訴え（X氏の推薦）",
      "藁人形論法 + 循環論法",
      "偽の二択 + 滑りやすい坂",
      "誤謬は含まれていない。合理的な営業トーク"
    ],
    "correctIndex": 0,
    "explanation": "A社での成果がB社で再現されるとは限りません（同業界でも規模・体制・課題が異なる）。また、コンサルタントの推薦は権威への訴えであり、手法の有効性の論理的根拠にはなりません。"
  },
  {
    "id": "ch6-p5",
    "type": "multiple-choice",
    "question": "コードレビューで後輩が「この関数が正しいことは、テストが通っていることから明らかです」と言いました。この主張の論理的な問題は？",
    "options": [
      "テストが通ることは正しさの必要条件であっても十分条件ではない。テストでカバーされていないケースが存在しうる",
      "循環論法。テストの正しさも証明されていない",
      "人身攻撃。後輩の能力を疑うべき",
      "論理的な問題はない。テストは正しさの証拠である"
    ],
    "correctIndex": 0,
    "explanation": "テストが通ること（Q）は正しさ（P）の必要条件かもしれませんが、十分条件ではありません。P → Q（正しい → テスト通過）は成り立つとして、Q → P（テスト通過 → 正しい）は後件肯定の誤謬です。エッジケースやテストされていないパスが存在する可能性があります。"
  },
  {
    "id": "ch6-p6",
    "type": "counterexample",
    "argument": "このコードレビューツールを使えば全てのバグが見つかる。我々はこのツールを使っている。ゆえに我々のコードにバグはない。",
    "premises": ["このコードレビューツールを使えば全てのバグが見つかる", "我々はこのツールを使っている"],
    "conclusion": "我々のコードにバグはない",
    "vulnerablePremiseIndex": 0,
    "counterexamples": [
      { "id": "ce1", "text": "コードレビューツールでは論理エラーや仕様の誤解を検出できない", "isValid": true },
      { "id": "ce2", "text": "我々のチームは優秀である", "isValid": false },
      { "id": "ce3", "text": "他のチームもこのツールを使っている", "isValid": false },
      { "id": "ce4", "text": "100%のバグ検出率を持つツールは存在しない", "isValid": true }
    ],
    "explanation": "「全てのバグが見つかる」という前提は誤り。静的解析ツールはパターンマッチによる検出であり、全てのバグを見つけることは原理的に不可能です（停止問題）。"
  },
  {
    "id": "ch6-p7",
    "type": "multiple-choice",
    "question": "データベースのINNER JOINはA ∩ Bに、LEFT JOINはA ∪ (A ∩ B)に相当します。A = {1,2,3,4}, B = {3,4,5,6}のとき、FULL OUTER JOIN (A ∪ B) の結果は？",
    "options": [
      "{1,2,3,4,5,6}",
      "{3,4}",
      "{1,2,5,6}",
      "{1,2,3,4}"
    ],
    "correctIndex": 0,
    "explanation": "A ∪ B は両方の集合のすべての要素を含みます。A = {1,2,3,4} と B = {3,4,5,6} の和集合は {1,2,3,4,5,6} です。FULL OUTER JOINは両テーブルのすべての行を返すため、集合の和集合に対応します。"
  },
  {
    "id": "ch6-p8",
    "type": "multiple-choice",
    "question": "チームの「同じプロジェクト」という関係が同値関係であるとき、同値類の意味は？",
    "options": [
      "同じプロジェクトのメンバー集合がチーム全体を互いに排他的に分割する",
      "すべてのメンバーが同じプロジェクトに所属する",
      "一部のメンバーが複数プロジェクトに属する",
      "プロジェクトは順序関係を持つ"
    ],
    "correctIndex": 0,
    "explanation": "同値関係（反射的・対称的・推移的）による同値類は、元の集合を互いに排他的な部分集合（分割）に分けます。「同じプロジェクト」が同値関係であれば、各メンバーはちょうど1つのプロジェクトに属し、プロジェクトごとのメンバー集合がチーム全体の分割を形成します。"
  },
  {
    "id": "ch6-p9",
    "type": "multiple-choice",
    "question": "「すべてのn≥1について、1+2+...+n = n(n+1)/2」の帰納法証明で、帰納ステップの仮定として正しいのは？",
    "options": [
      "ある自然数kについて 1+2+...+k = k(k+1)/2 が成り立つと仮定",
      "すべてのkについて成り立つと仮定",
      "k=1のとき成り立つと仮定",
      "k=nのとき成り立つことを証明"
    ],
    "correctIndex": 0,
    "explanation": "数学的帰納法の帰納ステップでは、「ある特定の自然数kについて命題が成り立つ」と仮定（帰納仮定）し、そこから「k+1についても成り立つ」ことを証明します。「すべてのk」ではなく「ある特定のk」について仮定する点が重要です。"
  },
  {
    "id": "ch6-p10",
    "type": "multiple-choice",
    "question": "再帰関数 fact(n) = n * fact(n-1), fact(0) = 1 の正しさを帰納法で証明する際、基底ケースは？",
    "options": [
      "fact(0) = 1 = 0! であることの確認",
      "fact(1) = 1 であることの確認",
      "fact(n) が停止することの確認",
      "再帰の深さが有限であることの確認"
    ],
    "correctIndex": 0,
    "explanation": "帰納法の基底ケースは再帰の停止条件に対応します。fact(0) = 1 と定義されており、0! = 1 と一致することを確認します。これが帰納法の出発点となり、帰納ステップで fact(k) = k! を仮定して fact(k+1) = (k+1)! を証明します。"
  },
  {
    "id": "ch6-p11",
    "type": "multiple-choice",
    "question": "ソフトウェア仕様書の「このシステムはクラッシュしない」を様相論理で表すと□¬Crash。これが偽となるのは？",
    "options": [
      "到達可能な世界の中に1つでもCrashが真の世界が存在する場合",
      "すべての世界でCrashが真の場合",
      "現在の世界でCrashが真の場合のみ",
      "Crashの定義が不明な場合"
    ],
    "correctIndex": 0,
    "explanation": "□¬Crash（必然的にクラッシュしない）が偽であるとは、¬□¬Crash、すなわち◇Crash（クラッシュする可能性がある）ことを意味します。到達可能な世界（状態）の中に1つでもCrashが真の世界があれば、□¬Crashは偽となります。"
  },
  {
    "id": "ch6-p12",
    "type": "multiple-choice",
    "question": "「ボタンを押したら、いつか必ず応答がある」をLTLで表すと G(press → F response)。これに違反するのは？",
    "options": [
      "ボタンを押した後、永遠に応答がない実行パスが存在する",
      "応答に1秒以上かかる場合",
      "ボタンを押さない場合",
      "応答が即座の場合"
    ],
    "correctIndex": 0,
    "explanation": "G（Globally）は「常に」、F（Finally）は「いつか必ず」を意味します。G(press → F response) は「どの時点でもpressが起きたら、いつか必ずresponseが起きる」です。違反するのは、pressの後にresponseが永遠に来ない実行パスが存在する場合です。応答の遅延自体は違反ではありません。"
  },
  {
    "id": "ch6-p13",
    "type": "multiple-choice",
    "question": "医療検査の感度95%、特異度90%、有病率1%のとき、陽性と出た人が実際に病気である確率は？",
    "options": [
      "約8.8%（ベイズの定理による計算）",
      "約95%（感度と同じ）",
      "約90%（特異度と同じ）",
      "約50%（情報不足のため不明）"
    ],
    "correctIndex": 0,
    "explanation": "ベイズの定理により P(D|+) = P(+|D)×P(D) / [P(+|D)×P(D) + P(+|¬D)×P(¬D)] = 0.95×0.01 / (0.95×0.01 + 0.10×0.99) = 0.0095 / (0.0095 + 0.099) ≈ 0.088。有病率が低い場合、陽性でも実際に病気である確率は意外に低くなります。これは基準率の無視（base rate neglect）を避ける重要な例です。"
  },
  {
    "id": "ch6-p14",
    "type": "counterexample",
    "argument": "この薬は臨床試験で効果があった。1000人中600人が改善した。ゆえにこの薬は効果的だ。",
    "premises": [
      "臨床試験で1000人中600人が改善した"
    ],
    "conclusion": "この薬は効果的だ",
    "vulnerablePremiseIndex": 0,
    "counterexamples": [
      { "id": "ce1", "text": "プラセボ群でも580人が改善していた（薬の効果は2%のみ）", "isValid": true },
      { "id": "ce2", "text": "改善の定義が主観的で測定にバイアスがある", "isValid": true },
      { "id": "ce3", "text": "1000人は十分なサンプルサイズである", "isValid": false },
      { "id": "ce4", "text": "薬は高価である", "isValid": false }
    ],
    "explanation": "臨床試験の結果を評価するには対照群（プラセボ群）との比較が不可欠です。1000人中600人が改善しても、プラセボ群で同程度の改善が見られれば薬の効果は小さいです。また、統計的有意性の検定、測定のバイアス、効果量の評価も必要です。"
  },
  {
    "id": "ch6-p15",
    "type": "multiple-choice",
    "question": "回路設計で A∧(A∨B) を簡約すると？",
    "options": [
      "A（吸収律による）",
      "A∨B",
      "A∧B",
      "B"
    ],
    "correctIndex": 0,
    "explanation": "吸収律（absorption law）により A∧(A∨B) = A です。直感的には、Aが真のとき A∨B は必ず真なので A∧(A∨B) = A∧真 = A、Aが偽のとき A∧(A∨B) = 偽∧(A∨B) = 偽 = A となります。回路設計ではこの簡約により不要なゲートを削減できます。"
  },
  {
    "id": "ch6-p16",
    "type": "multiple-choice",
    "question": "Curry-Howard対応において、関数 (a: A) => (b: B) => a の型 A → B → A は、論理的には何に対応？",
    "options": [
      "トートロジー P → (Q → P) に対応（常に証明可能）",
      "P ∧ Q → P に対応",
      "矛盾 ⊥ に対応",
      "排中律に対応"
    ],
    "correctIndex": 0,
    "explanation": "Curry-Howard対応では、型は命題に、プログラムは証明に対応します。関数 (a: A) => (b: B) => a は型 A → B → A を持ち、これは論理式 P → (Q → P) に対応します。この式はトートロジー（恒真式）であり、Kコンビネータとして知られています。任意の型A, Bについてこの関数を構成できることが、この命題が常に証明可能であることを示しています。"
  },
  {
    "id": "ch6-p17",
    "type": "multiple-choice",
    "question": "ゲーデルの第一不完全性定理が意味するのは？",
    "options": [
      "十分に強い形式体系には、証明も反証もできない真なる命題が存在する",
      "数学は矛盾している",
      "すべての命題は証明可能である",
      "形式化は意味がない"
    ],
    "correctIndex": 0,
    "explanation": "ゲーデルの第一不完全性定理は、自然数の算術を含む十分に強い無矛盾な形式体系には、その体系内で証明も反証もできない命題（決定不能命題）が必ず存在することを示しています。これは数学が矛盾しているということではなく、形式体系の本質的な限界を示す深い結果です。"
  },
  {
    "id": "ch6-p18",
    "type": "multiple-choice",
    "question": "停止問題が決定不能であることの実務的含意は？",
    "options": [
      "すべてのプログラムの停止を判定する万能ツールは作れない（ただし個別プログラムの分析は可能）",
      "プログラムは必ず無限ループする",
      "バグ検出ツールは無意味である",
      "すべてのプログラムは停止する"
    ],
    "correctIndex": 0,
    "explanation": "停止問題の決定不能性は、任意のプログラムと入力に対して停止するかどうかを判定する万能アルゴリズムが存在しないことを意味します。ただし、特定のプログラムや制限されたクラスのプログラムについては停止性を証明できる場合があります。実務では、静的解析ツールやモデル検査器が限定的ながら有用な停止性分析を提供しています。"
  }
]
