export function PhilosophyContent() {
  return (
    <article className="prose prose-zinc max-w-none">
      <h1>哲学コラム: ディリクレと関数概念の変遷</h1>

      <h2>「関数」以前の時代</h2>
      <p>
        17世紀、ニュートンとライプニッツが微積分を発明したとき、
        「関数」という概念はまだ存在しませんでした。
        彼らが扱っていたのは「曲線」や「量の変化」であり、
        入力と出力の対応関係として関数を捉える発想はありませんでした。
      </p>
      <p>
        「関数（functio）」という言葉を最初に用いたのはライプニッツですが、
        その意味は現在とは異なり、曲線上の点の座標のような幾何学的な量を指していました。
        18世紀のオイラーは関数を「解析的な式」として定義し、
        sin x、log x、x² + 3x のような式で表現できるものが関数だと考えました。
      </p>

      <h2>ディリクレの革命（1837年）</h2>
      <p>
        ペーター・グスタフ・ルジューヌ・ディリクレ（1805-1859）は、
        この状況を根本から変えました。
        1837年の論文で、ディリクレは関数の概念を大胆に拡張します。
      </p>
      <p>
        ディリクレの定義では、関数とは単に「各入力に対して出力が一意に定まる対応」であり、
        その対応が数式で表現できるかどうかは問いません。
        これは当時の数学者たちにとって衝撃的でした。
        「式で書けない対応」も関数なのか？
      </p>

      <h2>ディリクレ関数</h2>
      <p>
        ディリクレはこの点を劇的に示すため、次の関数を提示しました。
        f(x) = 1（x が有理数のとき）、f(x) = 0（x が無理数のとき）。
        この関数はグラフに描くことができず、数式で簡潔に表現することもできません。
        しかし、各実数に対して値が一意に定まるという意味では、
        立派な「関数」なのです。
      </p>
      <p>
        ディリクレ関数は、関数の本質が「式」や「グラフ」にあるのではなく、
        「対応規則」にあることを鮮やかに示しました。
        この認識は、数学が「計算の学問」から「構造の学問」へと変容していく
        大きな転換点となりました。
      </p>

      <h2>集合論的な関数の定義</h2>
      <p>
        カントールの集合論が発展すると、ディリクレの洞察はさらに精密化されます。
        関数は「順序対の集合」として定義されるようになりました。
        f: A → B とは、A × B の部分集合で、
        各 a ∈ A に対して (a, b) ∈ f となる b がちょうど1つ存在するもの。
      </p>
      <p>
        この定義は究極的に抽象的です。
        関数の「中身」——どのような計算や規則で出力が決まるか——は問いません。
        入力と出力の対応関係のみが関数を定義します。
        この考え方は、現代のプログラミングにおける「インターフェース」の思想と共鳴します。
        外部から見た振る舞い（入出力）が同じなら、内部の実装は問わない。
      </p>

      <h2>関数概念とコンピュータ科学</h2>
      <p>
        ディリクレの革命は、200年後のコンピュータ科学に直接つながっています。
        チャーチのラムダ計算は、関数を計算の基本単位とする体系であり、
        Haskell や Scala などの関数型プログラミング言語の理論的基盤です。
      </p>
      <p>
        特に「参照透過性」——同じ入力に対して常に同じ出力を返す——は、
        ディリクレの関数定義の核心そのものです。
        「純粋関数」を重視する現代のプログラミングの潮流は、
        19世紀の数学者が切り拓いた概念の再発見ともいえるでしょう。
      </p>

      <h2>あなたが学んだことの起源</h2>
      <p>
        第16章で学んだ単射・全射・全単射の概念は、
        関数の構造的な性質を分類するための道具です。
        ディリクレが示したように、関数の本質は「式」ではなく「対応」にあります。
        プログラムを書くとき、あなたは常に関数——入力を受け取り出力を返す対応——を設計しています。
        その設計が単射的か（情報を失わないか）、
        全射的か（すべての出力をカバーするか）を意識することは、
        より堅牢なソフトウェアを構築する第一歩です。
      </p>
    </article>
  )
}
