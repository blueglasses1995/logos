import {
  Callout,
  FormulaBlock,
  ComparisonTable,
  KeyPoint,
  SectionDivider,
} from "@/components/content"
import { VennDiagram, InlineMiniQuiz } from "@/components/interactive"

export function TheoryContent() {
  return (
    <article className="prose prose-zinc max-w-none">
      <h1>第4e章: 多重量化 — 量化子の入れ子と順序</h1>

      <h2>定義: 多重量化とは何か</h2>

      <Callout variant="definition" label="定義">
        <strong>多重量化（multiple quantification）</strong>とは、
        量化子を複数組み合わせて入れ子にすることです。
        述語が2つ以上の変数を持つとき、各変数に対して量化子を付ける必要があります。
      </Callout>

      <p>
        たとえば「すべてのxに対して、あるyが存在してP(x, y)が成り立つ」は次のように書きます。
      </p>

      <FormulaBlock caption="多重量化の基本形">
        ∀x ∃y P(x, y)
      </FormulaBlock>

      <p>
        ここで重要なのは、<strong>量化子の順序が意味を決定的に変える</strong>ということです。
        ∀x ∃y と ∃y ∀x は、一見似ていますが、まったく異なる主張をしています。
      </p>

      <p>
        この章では、量化子の順序がなぜ重要なのか、
        順序を間違えるとどのような誤りが生じるのかを徹底的に理解します。
      </p>

      <KeyPoint>
        多重量化では、量化子の順序が論理式の意味を根本的に変える。
        ∀x ∃y と ∃y ∀x は異なる主張である。
      </KeyPoint>

      <SectionDivider />

      <h2>核心: 量化子の順序が意味を変える</h2>

      <h3>∀x ∃y P(x, y) — 「各xに対して（別々の）yが存在する」</h3>

      <p>
        <code>∀x ∃y P(x, y)</code> は次のように読みます。
        「すべてのxに対して、P(x, y)を満たすyが（少なくとも1つ）存在する」。
      </p>

      <p>
        ここで重要なのは、<strong>yはxに依存してよい</strong>ということです。
        xが変われば、それに対応するyも変わって構いません。
        つまり、x₁に対してはy₁、x₂に対してはy₂、x₃に対してはy₃ ... というように、xごとに別々のyが選ばれます。
      </p>

      <h3>∃y ∀x P(x, y) — 「ある1つのyが存在して、すべてのxに対して成り立つ」</h3>

      <p>
        <code>∃y ∀x P(x, y)</code> は次のように読みます。
        「あるyが存在して、そのyがすべてのxに対してP(x, y)を満たす」。
      </p>

      <p>
        こちらは<strong>yが先に1つ固定</strong>されます。
        そして、その固定された1つのyが、すべてのxに対して同時に機能しなければなりません。
        これは ∀x ∃y よりもはるかに強い主張です。
      </p>

      <ComparisonTable
        headers={["∀x ∃y P(x, y)", "∃y ∀x P(x, y)"]}
        rows={[
          [
            "各xに対して（別々の）yが存在する",
            "ある1つのyがすべてのxに対して成り立つ",
          ],
          [
            "yはxに依存してよい",
            "yを先に1つ固定する",
          ],
          [
            "弱い主張",
            "強い主張（こちらが真なら左も真）",
          ],
          [
            "x₁→y₁, x₂→y₂, x₃→y₃ ...",
            "y₀がx₁, x₂, x₃ ... すべてに対応",
          ],
        ]}
      />

      <h3>論理的な関係</h3>

      <p>
        <code>∃y ∀x P(x, y)</code> が真ならば、<code>∀x ∃y P(x, y)</code> も必ず真です。
        1つのyがすべてのxに対して機能するなら、各xに対するyとしてその同じyを使えばよいからです。
      </p>

      <p>
        しかし、逆は成り立ちません。
        各xに対して別々のyが存在しても、すべてのxに共通する1つのyが存在するとは限りません。
      </p>

      <FormulaBlock caption="含意の方向">
        ∃y ∀x P(x, y) → ∀x ∃y P(x, y) は常に成り立つ
      </FormulaBlock>
      <FormulaBlock caption="逆は一般に不成立">
        ∀x ∃y P(x, y) → ∃y ∀x P(x, y) は一般に成り立たない
      </FormulaBlock>

      <KeyPoint>
        ∃y ∀x は ∀x ∃y より強い主張である。
        前者が真なら後者も真だが、逆は成り立たない。
      </KeyPoint>

      <VennDiagram
        labelA="∀x∃y R(x,y)"
        labelB="∃y∀x R(x,y)"
        highlight={["a-only", "intersection", "b-only"]}
        formulaLabel="量化子の順序で意味が変わる"
        interactive
      />

      <SectionDivider />

      <h2>具体例: 順序の違いを体感する</h2>

      <h3>日常: 親の例</h3>

      <p>
        述語 <code>Parent(y, x)</code> を「yはxの親である」と定義します。
      </p>

      <ComparisonTable
        headers={["∀x ∃y Parent(y, x)", "∃y ∀x Parent(y, x)"]}
        rows={[
          [
            "すべての人xに対して、xの親yが存在する",
            "ある人yが存在して、その人yがすべての人xの親である",
          ],
          [
            "真 — すべての人には親がいる（人によって親は異なる）",
            "偽 — 全人類共通の親は存在しない",
          ],
        ]}
      />

      <p>
        ∀x ∃y では各人が自分の親を持てばよく、
        ∃y ∀x では一人の人物が全員の親でなければなりません。
        順序を入れ替えただけで、真から偽に変わりました。
      </p>

      <h3>ビジネス: ユーザーとロール</h3>

      <p>
        述語 <code>HasRole(x, y)</code> を「ユーザーxはロールyを持つ」と定義します。
      </p>

      <ComparisonTable
        headers={[
          "∀x(User(x) → ∃y HasRole(x, y))",
          "∃y ∀x(User(x) → HasRole(x, y))",
        ]}
        rows={[
          [
            "すべてのユーザーは少なくとも1つのロールを持つ",
            "あるロールyが存在して、すべてのユーザーがそのロールyを持つ",
          ],
          [
            "各自に何かしらのロールがあればよい（管理者、閲覧者、編集者 ...）",
            "全員が同じ特定のロールを持つ（例: 全員がログインロールを持つ）",
          ],
        ]}
      />

      <Callout variant="warning" label="よくある誤解">
        アクセス制御の設計で順序を間違えると、セキュリティの要件をまったく異なる形で定義してしまいます。
        「各自にロールがある」と「全員が同じロールを持つ」は根本的に異なる要件です。
      </Callout>

      <h3>数学: ε-δ論法</h3>

      <p>
        解析学における関数の連続性の定義は、多重量化の最も有名な応用例です。
      </p>

      <FormulaBlock caption="関数の連続性（点aにおける）">
        {"∀ε > 0, ∃δ > 0, ∀x (|x - a| < δ → |f(x) - f(a)| < ε)"}
      </FormulaBlock>

      <p>
        この定義では量化子の順序が本質的です。
        「任意のε（許容誤差）に対して、適切なδ（近傍の幅）が存在する」という構造であり、
        δはεに依存して選ばれます。
      </p>

      <p>
        もし順序を変えて <code>{"∃δ > 0, ∀ε > 0, ..."}</code> としてしまうと、
        「1つのδがすべてのεに対して機能する」という意味になります。
        εをどれだけ小さく取っても同じδで対応できるということは、通常の連続性よりもはるかに強い主張です。
      </p>

      <Callout variant="tip">
        フレーゲが述語論理を発明した動機の一つは、まさにこのような
        多重量化を含む数学的概念を厳密に表現するためでした。
      </Callout>

      <h3>プログラミング: ネストされたループ</h3>

      <p>
        多重量化はプログラムのネストされたループに直接対応します。
        <code>∀x ∃y P(x, y)</code> は次のようなコードに対応します。
      </p>

      <FormulaBlock caption="∀x ∃y — 外側にevery、内側にsome">
        {"items.every(x => candidates.some(y => P(x, y)))"}
      </FormulaBlock>

      <p>
        「すべてのxについて、P(x, y)を満たすyがcandidatesの中に存在するか」を検証しています。
        外側のループ（every/∀）の各反復で、内側のループ（some/∃）が独立に探索します。
      </p>

      <p>
        一方、<code>∃y ∀x P(x, y)</code> は次のように対応します。
      </p>

      <FormulaBlock caption="∃y ∀x — 外側にsome、内側にevery">
        {"candidates.some(y => items.every(x => P(x, y)))"}
      </FormulaBlock>

      <p>
        「あるyが存在して、そのyがすべてのxについてP(x, y)を満たすか」を検証しています。
        こちらは1つのyを固定してから、すべてのxに対してチェックします。
      </p>

      <h3>SQL: 相関サブクエリ</h3>

      <p>
        SQLにおける多重量化は相関サブクエリとして表現されます。
      </p>

      <FormulaBlock caption="∀x ∃y — すべてのプロジェクトに少なくとも1人の担当者がいる">
        {"SELECT * FROM projects p WHERE NOT EXISTS (SELECT 1 FROM projects p2 WHERE p2.id = p.id AND NOT EXISTS (SELECT 1 FROM assignments a WHERE a.project_id = p2.id))"}
      </FormulaBlock>

      <FormulaBlock caption="∃y ∀x — ある社員がすべてのプロジェクトに参加している">
        {"SELECT * FROM employees e WHERE NOT EXISTS (SELECT 1 FROM projects p WHERE NOT EXISTS (SELECT 1 FROM assignments a WHERE a.employee_id = e.id AND a.project_id = p.id))"}
      </FormulaBlock>

      <p>
        NOT EXISTSの入れ子構造が多重量化に対応します。
        クエリの意味が正しいかどうかは、量化子の順序を正確に把握することで判断できます。
      </p>

      <h3>法律: 契約と証人</h3>

      <p>
        「すべての契約には少なくとも1人の証人が必要である」を考えます。
      </p>

      <ComparisonTable
        headers={[
          "∀x(...→ ∃y ...)",
          "∃y(... ∧ ∀x(... → ...))",
        ]}
        rows={[
          [
            "各契約に（それぞれ別の）証人がいればよい",
            "ある1人の証人がすべての契約に立ち会っている",
          ],
          [
            "契約Aの証人は田中さん、契約Bの証人は鈴木さんで構わない",
            "「専任の証人」が全契約をカバーする限定的な状況",
          ],
        ]}
      />

      <p>
        法的な文脈では、この区別が実務に直結します。
        前者なら契約ごとに異なる証人を用意できますが、
        後者ならすべての契約に同一人物が関与する必要があります。
      </p>

      <KeyPoint>
        日常・ビジネス・数学・プログラミング・SQL・法律のすべての分野で、
        ∀x ∃y と ∃y ∀x の区別が実質的な意味の違いを生む。
      </KeyPoint>

      <InlineMiniQuiz
        question="∀x∃y Loves(x,y) の正しい読みは？"
        options={["すべての人について、その人が愛する誰かが存在する", "ある人が存在して、すべての人がその人を愛する", "すべての人がすべての人を愛する", "誰かが誰かを愛する"]}
        correctIndex={0}
        explanation="∀xが先に来るため「すべてのxについて」が外側、∃yが内側で「あるyが存在する」。各人ごとに異なるyでよい。"
      />

      <SectionDivider />

      <h2>成り立たない例: 順序の入れ替えが真偽を変える</h2>

      <p>
        ∀x ∃y と ∃y ∀x が異なることを、さらに明確な反例で確認します。
        述語 <code>GreaterThan(y, x)</code> を「y &gt; x」（yはxより大きい）とし、対象領域を自然数とします。
      </p>

      <ComparisonTable
        headers={["∀x ∃y (y > x)", "∃y ∀x (y > x)"]}
        rows={[
          [
            "すべての自然数xに対して、xより大きい自然数yが存在する",
            "ある自然数yが存在して、すべての自然数xより大きい",
          ],
          [
            "真 — どんなxにも x+1 を取ればよい（xごとに異なるy）",
            "偽 — 自然数に最大値は存在しない。どんなyにも y+1 というxがある",
          ],
        ]}
      />

      <p>
        この例は、∀x ∃y では y が x に依存して変化できるのに対し、
        ∃y ∀x では y を先に1つ固定しなければならないという違いを鮮明に示しています。
      </p>

      <h3>同じ種類の量化子が並ぶ場合</h3>

      <Callout variant="tip">
        <strong>同じ種類の量化子が並ぶ場合は順序を交換できます。</strong>
        順序が重要になるのは、∀ と ∃ が混在する場合だけです。
      </Callout>

      <FormulaBlock caption="同種の量化子は交換可能">
        ∀x ∀y P(x, y) ≡ ∀y ∀x P(x, y)
      </FormulaBlock>
      <FormulaBlock>
        ∃x ∃y P(x, y) ≡ ∃y ∃x P(x, y)
      </FormulaBlock>

      <p>
        「すべてのxとすべてのyについてP(x, y)」は、x と y のどちらを先に考えても同じです。
        「あるxとあるyが存在してP(x, y)」も同様です。
      </p>

      <KeyPoint>
        同種の量化子（∀∀ や ∃∃）は自由に交換可能だが、
        ∀ と ∃ が混在する場合は順序の交換が意味を変える。
      </KeyPoint>

      <SectionDivider />

      <h2>どこで使われるか / なぜ学ぶのか</h2>

      <h3>データベース設計</h3>

      <p>
        相関サブクエリの正しさを判断するには、量化子の順序を理解する必要があります。
        「すべての注文に対して配送先が存在する」（∀x ∃y）と「ある配送先がすべての注文に使われている」（∃y ∀x）は
        ビジネス要件として全く異なります。
      </p>

      <p>
        SQLのNOT EXISTSを正しく入れ子にするには、この順序の違いを正確に把握しなければなりません。
      </p>

      <h3>数学の基礎</h3>

      <p>
        解析学のε-δ論法、極限の定義、一様連続性と点ごとの連続性の違いは、
        すべて量化子の順序の違いで定義が分かれます。
      </p>

      <ComparisonTable
        headers={["一様連続", "点ごとの連続"]}
        rows={[
          [
            "∀ε ∃δ ∀x ...",
            "∀x ∀ε ∃δ ...",
          ],
          [
            "δがxに依存しない",
            "δがxに依存してよい",
          ],
        ]}
      />

      <p>
        量化子の順序を正しく読めなければ、これらの定義を理解することは不可能です。
      </p>

      <h3>プログラミング</h3>

      <p>
        依存性注入（DI）のパターンは多重量化に対応します。
        「すべてのサービスに対して、適切な実装が存在する」（∀x ∃y）は各サービスごとに異なる実装を注入できます。
        「ある1つの実装がすべてのサービスに使える」（∃y ∀x）は汎用的な実装を求めるものです。
      </p>

      <p>
        ネストされたループの計算量やAPIの設計においても、
        「各リクエストに対して適切なハンドラがある」のか「1つのハンドラがすべてのリクエストを処理する」のかは根本的に異なります。
      </p>

      <h3>正しく理解しないとどうなるか</h3>

      <Callout variant="warning" label="よくある誤解">
        量化子の順序を間違えると、仕様が意図と異なるものになります。
        「各ユーザーが自分のパスワードを持つ」システムと「全ユーザーが同一のパスワードを共有する」システムは、
        セキュリティの観点から天と地ほど異なります。
        しかし形式的には ∀x ∃y と ∃y ∀x の違いに過ぎません。
      </Callout>

      <KeyPoint>
        データベース・数学・プログラミングのすべてで、量化子の順序を正しく読み書きする能力が不可欠である。
      </KeyPoint>

      <SectionDivider />

      <h2>よくある誤解</h2>

      <h3>誤解1: 量化子の順序は自由に交換できる</h3>

      <Callout variant="warning" label="よくある誤解">
        「∀x ∃y と ∃y ∀x は同じ意味だ」と思ってしまう人は多いですが、これは完全に誤りです。
        ∀x ∃y ではyがxに依存できますが、∃y ∀x ではyを先に固定しなければなりません。
        この違いは、親の例や自然数の例で見た通り、真偽を根本的に変えてしまいます。
      </Callout>

      <h3>誤解2: 日本語の語順と量化子の順序は対応する</h3>

      <Callout variant="warning" label="よくある誤解">
        「すべてのxに対してあるyが存在する」と「あるyが存在してすべてのxに対して成り立つ」は、
        日本語としては微妙な違いに見えるかもしれません。
        しかし論理的には全く異なる主張です。
        日本語の自然な語順に惑わされず、「yはxに依存するか否か」を常に意識してください。
      </Callout>

      <h3>誤解3: ∃y ∀x が成り立てば ∀x ∃y も成り立つから、区別は不要</h3>

      <Callout variant="warning" label="よくある誤解">
        確かに ∃y ∀x → ∀x ∃y は成り立ちます。
        しかし逆は成り立たないため、区別は必須です。
        ∀x ∃y が成り立つことを確認しても、∃y ∀x が成り立つとは限りません。
        仕様として ∃y ∀x が必要な場面で ∀x ∃y しか確認しないと、要件を満たさないシステムができてしまいます。
      </Callout>

      <h3>順序を交換しても安全な場合</h3>

      <Callout variant="tip">
        例外的に、対象領域が有限で、述語が特定の単調性条件を満たす場合は、順序の交換が安全なことがあります。
        また、同じ種類の量化子（∀∀ や ∃∃）は自由に交換可能です。
        しかし一般的には、∀ と ∃ が混在する場合は順序の交換は許されないと考えるべきです。
      </Callout>

      <KeyPoint>
        量化子の順序交換は、同種の量化子のみ安全。
        ∀ と ∃ が混在する場合、順序は意味を決定的に変えるため、常に慎重に読み書きすること。
      </KeyPoint>
    </article>
  )
}
