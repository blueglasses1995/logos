import {
  Callout,
  FormulaBlock,
  ComparisonTable,
  KeyPoint,
  SectionDivider,
  MotivationSection,
} from "@/components/content"
import {
  ExampleMapping,
  InlineMiniQuiz,
  ArgumentTree,
  StudyNotes,
} from "@/components/interactive"

export function TheoryContent() {
  return (
    <>
    <article className="prose prose-zinc max-w-none">
      <h1>第29章: メタ論理：限界と可能性</h1>

      <MotivationSection
        icon="🏔️"
        realWorldExample="ソフトウェアに「バグがない」ことを完全に証明できるか？ 停止問題は、この問いに原理的な限界があることを示す。"
        nextChapterConnection="論理学の全体像を振り返り、学びの旅の次のステップへ"
      />

      <h2>対象言語とメタ言語の区別</h2>

      <p>
        これまで私たちは論理学の「中」で推論を行ってきました。
        命題を組み合わせ、真理値表を作り、証明を構築しました。
        この章では視点を大きく変えます。
        論理学そのものを「外」から観察し、
        論理体系の性質について考える<strong>メタ論理学</strong>に踏み込みます。
      </p>

      <Callout variant="definition" label="対象言語とメタ言語">
        <ul>
          <li><strong>対象言語</strong>: 研究の対象となる形式体系の言語。例えば命題論理の式 P → Q。</li>
          <li><strong>メタ言語</strong>: 対象言語について語るために使う言語。「P → Q は恒真式である」という文はメタ言語で書かれている。</li>
        </ul>
      </Callout>

      <p>
        例えば「P ∨ ¬P は恒真式である」という文を考えます。
        P ∨ ¬P は対象言語（命題論理）の式です。
        「〜は恒真式である」はメタ言語の述語です。
        この区別は、ゲーデルの定理を理解する上で決定的に重要です。
      </p>

      <ExampleMapping
        formula="P ∨ ¬P"
        example="「P ∨ ¬P は恒真式である」"
        variables={{
          "P ∨ ¬P": "対象言語の式",
          "恒真式である": "メタ言語の述語",
          "全体の文": "メタ言語の文（対象言語についての主張）",
        }}
        caption="対象言語とメタ言語のレベルの違い"
      />

      <Callout variant="warning" label="レベルの混同に注意">
        「この文は偽である」というパラドックス（嘘つきのパラドックス）は、
        対象言語とメタ言語のレベルを混同することで生じます。
        文が自分自身の真偽について語ることを許すと、
        矛盾が発生するのです。
        ゲーデルはこのパラドックスの構造を巧妙に利用しました。
      </Callout>

      <KeyPoint>
        メタ論理学は、論理体系そのものの性質を研究する分野。
        対象言語（論理式）とメタ言語（論理体系についての言明）の
        区別が出発点となる。
      </KeyPoint>

      <SectionDivider />

      <h2>ゲーデルの第一不完全性定理</h2>

      <p>
        1931年、25歳のクルト・ゲーデルは、
        数学の基礎に関する最も衝撃的な定理を証明しました。
        それは、数学の完全性という夢に決定的な限界があることを示すものでした。
      </p>

      <Callout variant="definition" label="第一不完全性定理（非形式的な記述）">
        自然数の算術を含む、十分に強い無矛盾な形式体系には、
        その体系の中で<strong>証明も反証もできない</strong>文が必ず存在する。
      </Callout>

      <p>
        この定理の意味を理解するために、いくつかの用語を確認しましょう。
      </p>

      <ComparisonTable
        headers={["概念", "意味"]}
        rows={[
          ["無矛盾（consistent）", "矛盾（A ∧ ¬A）が導かれない"],
          ["完全（complete）", "全ての文が証明可能か反証可能"],
          ["十分に強い", "自然数の加法と乗法を表現できる"],
          ["決定不能文", "証明も反証もできない文"],
        ]}
      />

      <p>
        ゲーデル以前、数学者たちは
        「十分に強い形式体系なら全ての真なる数学的命題を証明できるはずだ」
        と期待していました。
        特にダフィット・ヒルベルトは1920年代に、
        数学の全てを有限的な方法で基礎づける壮大な計画（ヒルベルト・プログラム）を提唱しました。
        ゲーデルの定理は、この計画が原理的に実現不可能であることを示したのです。
      </p>

      <KeyPoint>
        第一不完全性定理: 自然数論を含む無矛盾な形式体系は、必ず不完全である。
        つまり、体系の中で「真だが証明できない」文が存在する。
      </KeyPoint>

      <SectionDivider />

      <h2>ゲーデル文の直感的構成</h2>

      <p>
        ゲーデルの証明の核心は、体系の中で
        「この文は証明できない」と言う文を構成することです。
        これは嘘つきのパラドックスに似ていますが、
        決定的な違いがあります。
      </p>

      <h3>ゲーデル数</h3>

      <p>
        ゲーデルの最初の巧妙な発想は、
        論理式や証明を<strong>自然数にコード化</strong>することでした。
        各記号に番号を割り当て、式の列を自然数にコード化します。
        これにより、「式xが文yの証明である」という関係を、
        自然数についての算術的な関係として表現できます。
      </p>

      <Callout variant="example" label="ゲーデル数の直感">
        コンピュータでは全てのデータが0と1の列（自然数）で表現されます。
        ゲーデルは1931年にこれと本質的に同じアイデアを使いました。
        論理式「P → Q」を、例えば数値 2^3 × 3^5 × 5^7 のように
        素因数分解を用いてコード化するのです。
      </Callout>

      <h3>自己言及文の構成</h3>

      <p>
        ゲーデル数を使うと、形式体系の中で
        自分自身について語る文を構成できます。
        G を次のような文とします。
      </p>

      <FormulaBlock caption="ゲーデル文 G">
        G : 「G のゲーデル数を持つ文は、この体系で証明できない」{"\n"}
        すなわち G : 「G は証明できない」
      </FormulaBlock>

      <p>
        この文 G について、二つの場合を考えます。
      </p>

      <ArgumentTree
        premises={[
          "G が証明可能と仮定する",
          "すると G は真（証明可能な文は真）",
          "G は「G は証明できない」と主張している",
          "矛盾：G は証明可能かつ証明不可能"
        ]}
        conclusion="G は証明可能ではない"
        rule="背理法"
        caption="ケース1: G が証明可能と仮定すると矛盾"
      />

      <p>
        G が証明可能だと矛盾します。
        したがって G は証明不可能です。
        しかし G は「G は証明できない」と主張しているので、
        G は<strong>真</strong>です。
        つまり G は「真だが証明できない」文なのです。
      </p>

      <ArgumentTree
        premises={[
          "G は証明不可能（上で示した）",
          "G は「G は証明できない」と主張している",
          "G の主張は正しい（実際に証明できない）"
        ]}
        conclusion="G は真だが証明できない文である"
        rule="メタレベルの推論"
        caption="ケース2: G は真だが体系内では証明できない"
      />

      <Callout variant="warning" label="嘘つきのパラドックスとの違い">
        嘘つきのパラドックス「この文は偽である」は矛盾を引き起こします。
        ゲーデル文「この文は証明できない」は矛盾を引き起こしません。
        なぜなら「真である」ことと「証明できる」ことは異なるからです。
        ゲーデルの定理はまさにこの区別を明らかにしました。
      </Callout>

      <InlineMiniQuiz
        question="ゲーデル文 G「G は証明できない」について正しいのはどれですか？"
        options={[
          "G は真だが、体系内で証明できない",
          "G は偽であり、矛盾を引き起こす",
          "G は真であり、体系内で証明できる",
          "G は真でも偽でもない"
        ]}
        correctIndex={0}
        explanation="G が証明可能だと矛盾するので、G は証明不可能です。しかし G は「G は証明できない」と主張しており、実際に証明できないのでこの主張は真です。よって G は「真だが証明できない」文です。"
      />

      <SectionDivider />

      <h2>第二不完全性定理</h2>

      <p>
        ゲーデルは第一不完全性定理に続いて、
        さらに衝撃的な結果を導きました。
      </p>

      <Callout variant="definition" label="第二不完全性定理">
        十分に強い無矛盾な形式体系は、
        <strong>自分自身の無矛盾性を証明できない</strong>。
      </Callout>

      <p>
        これは「Con(S)」を「体系 S は無矛盾である」という文とすると、
        S が無矛盾であれば Con(S) は S の中で証明できない、ということです。
      </p>

      <FormulaBlock caption="第二不完全性定理">
        S が無矛盾な十分に強い体系ならば:{"\n"}
        S ⊬ Con(S){"\n"}
        （S は自身の無矛盾性 Con(S) を証明できない）
      </FormulaBlock>

      <p>
        直感的な理由はこうです。
        もし S が Con(S)（S は無矛盾）を証明できたとします。
        第一不完全性定理の証明では、
        「S が無矛盾ならばゲーデル文 G は証明不可能」が示されました。
        S の中で Con(S) が証明できるなら、
        S の中で「G は証明不可能」も証明でき、
        これは G そのものの証明に相当します。
        しかし G は証明不可能なはずなので矛盾します。
      </p>

      <ExampleMapping
        formula="S ⊬ Con(S)"
        example="数学は、自分自身が矛盾していないことを数学自身の中で証明できない"
        variables={{
          "S": "形式的な数学体系（例: ペアノ算術）",
          "Con(S)": "「S は無矛盾である」というメタ命題",
          "⊬": "証明できない",
        }}
        caption="第二不完全性定理の意味"
      />

      <KeyPoint>
        第二不完全性定理により、数学の無矛盾性を数学自身の中で証明することは
        原理的に不可能である。
        これはヒルベルト・プログラムに対する決定的な否定回答だった。
      </KeyPoint>

      <SectionDivider />

      <h2>決定可能性と半決定可能性</h2>

      <p>
        ゲーデルの定理は「何が証明できるか」の限界を示しましたが、
        「何が計算できるか」にも同様の限界があります。
        ここで重要な概念が<strong>決定可能性</strong>です。
      </p>

      <Callout variant="definition" label="決定可能性">
        <ul>
          <li><strong>決定可能（decidable）</strong>: 任意の入力に対して、有限時間内に「Yes」か「No」を返すアルゴリズムが存在する。</li>
          <li><strong>半決定可能（semi-decidable）</strong>: 答えが「Yes」の場合は有限時間内に停止するが、「No」の場合は永遠に停止しないかもしれない。</li>
          <li><strong>決定不能（undecidable）</strong>: 決定可能なアルゴリズムが存在しない。</li>
        </ul>
      </Callout>

      <ComparisonTable
        headers={["問題", "決定可能性", "説明"]}
        rows={[
          ["命題論理の恒真式判定", "決定可能", "真理値表で全パターン検証可能"],
          ["述語論理の恒真式判定", "半決定可能", "証明があれば見つかるが、ないとき停止しない"],
          ["停止問題", "決定不能", "任意のプログラムの停止を判定不可能"],
          ["ペアノ算術の定理判定", "半決定可能", "証明探索は可能だが完全ではない"],
        ]}
      />

      <p>
        命題論理は決定可能です。変数の数が有限なので、真理値表で判定できます
        （ただし変数が増えると計算量は指数的に増加します）。
        しかし述語論理（第4章〜）になると状況は一変します。
        チャーチとチューリングは1936年に、
        述語論理の一般的な恒真式判定が決定不能であることを独立に証明しました。
      </p>

      <InlineMiniQuiz
        question="命題論理の恒真式判定が決定可能である理由は何ですか？"
        options={[
          "変数の数が有限なので、真理値表で全パターンを検証できるから",
          "ゲーデルの完全性定理により証明が保証されるから",
          "全ての命題が恒真式だから",
          "述語論理に帰着できるから"
        ]}
        correctIndex={0}
        explanation="命題論理の変数が n 個の場合、2^n 行の真理値表で全ての可能な真偽の組み合わせを網羅的に検証できます。有限ステップで判定が完了するので決定可能です。"
      />

      <SectionDivider />

      <h2>停止問題: チューリングの証明</h2>

      <p>
        1936年、アラン・チューリングは計算の限界に関する
        根本的な定理を証明しました。
        <strong>停止問題</strong>は決定不能である、というものです。
      </p>

      <Callout variant="definition" label="停止問題">
        「任意のプログラム P と入力 x が与えられたとき、
        P(x) が有限時間で停止するかどうかを判定する」
        という問題を停止問題と呼びます。
      </Callout>

      <p>
        チューリングは、停止問題を解くプログラムが存在しないことを
        <strong>対角線論法</strong>によって証明しました。
        この証明はカントルの対角線論法（第14章）と同じ構造を持っています。
      </p>

      <h3>チューリングの証明（概要）</h3>

      <p>
        停止問題を解くプログラム H が存在すると仮定します。
        H(P, x) は、プログラム P が入力 x で停止するなら「停止」を返し、
        停止しないなら「非停止」を返すとします。
      </p>

      <FormulaBlock caption="矛盾するプログラム D の構成">
        D(P) の定義:{"\n"}
        {"  "}もし H(P, P) = 「停止」 ならば 無限ループ{"\n"}
        {"  "}もし H(P, P) = 「非停止」 ならば 停止
      </FormulaBlock>

      <p>
        ここで D(D) を実行するとどうなるでしょうか。
      </p>

      <ArgumentTree
        premises={[
          "D(D) が停止すると仮定する",
          "H(D, D) = 「停止」",
          "D の定義により D(D) は無限ループ",
          "矛盾: D(D) は停止かつ非停止"
        ]}
        conclusion="D(D) は停止しない"
        rule="背理法"
        caption="D(D) が停止すると矛盾"
      />

      <ArgumentTree
        premises={[
          "D(D) が停止しないと仮定する",
          "H(D, D) = 「非停止」",
          "D の定義により D(D) は停止",
          "矛盾: D(D) は非停止かつ停止"
        ]}
        conclusion="D(D) は停止する"
        rule="背理法"
        caption="D(D) が停止しないとしても矛盾"
      />

      <p>
        どちらの場合も矛盾が生じます。
        したがって、最初の仮定「停止問題を解くプログラム H が存在する」が誤りです。
        停止問題は決定不能なのです。
      </p>

      <Callout variant="example" label="対角線論法との接続">
        カントルの対角線論法（第14章）を思い出してください。
        カントルは実数の全体と自然数の全体が一対一対応しないことを、
        仮想的な対応表の「対角線」を使って証明しました。
        チューリングの証明も同じ構造です。
        プログラム P に入力 P を与える（自分自身を入力にする）という
        「対角線」の操作が矛盾を導きます。
      </Callout>

      <KeyPoint>
        停止問題は決定不能。
        任意のプログラムの停止を判定する万能アルゴリズムは存在しない。
        この証明は対角線論法を用いており、
        カントルの集合論の結果と深い構造的類似性を持つ。
      </KeyPoint>

      <InlineMiniQuiz
        question="チューリングの停止問題の証明で使われた手法は何ですか？"
        options={[
          "対角線論法（自己言及による矛盾の導出）",
          "数学的帰納法",
          "真理値表による全数検査",
          "ブール代数の公理からの演繹"
        ]}
        correctIndex={0}
        explanation="チューリングは、停止判定器 H が存在すると仮定し、H を使って自分自身を入力とする矛盾するプログラム D を構成しました。これはカントルの対角線論法と同じ構造の証明です。"
      />

      <SectionDivider />

      <h2>論理学の限界と可能性</h2>

      <p>
        ゲーデルの不完全性定理と停止問題は、
        論理と計算の限界を示す否定的な結果です。
        しかし、これらの結果は論理学の「失敗」ではありません。
        むしろ、論理学が自身の限界を厳密に証明できるほど
        強力であることの証です。
      </p>

      <ComparisonTable
        headers={["限界", "それでも可能なこと"]}
        rows={[
          ["全ての真なる命題を証明できない", "多くの有用な定理は証明できる"],
          ["無矛盾性を内部証明できない", "相対的無矛盾性は証明できる"],
          ["停止問題を一般的に解けない", "多くの具体的プログラムの停止は証明できる"],
          ["述語論理は決定不能", "命題論理は決定可能。部分クラスも決定可能"],
        ]}
      />

      <p>
        実用的な観点では、不完全性定理の限界に直面することは稀です。
        日常の数学やプログラミングで必要な定理のほとんどは証明可能であり、
        多くのプログラムの停止は具体的に確認できます。
        限界は「原理的な」限界であり、実践を否定するものではありません。
      </p>

      <Callout variant="example" label="不完全性定理の現代的意義">
        ゲーデルの定理は、AI や自動定理証明の分野にも影響を与えています。
        完全に自動化された数学の証明は原理的に不可能ですが、
        人間と機械が協力する「証明支援系」（前章のCoq, Agdaなど）は
        強力なツールとして発展しています。
        限界を知ることで、より賢明なアプローチが可能になるのです。
      </Callout>

      <ExampleMapping
        formula="不完全性定理の含意"
        example="万能のバグ検出ツールは原理的に存在しない"
        variables={{
          "形式体系": "プログラムの正しさを検証するシステム",
          "決定不能文": "検出できないバグのクラスが必ず存在する",
          "停止問題": "プログラムが無限ループするかの一般的判定は不可能",
        }}
        caption="ソフトウェア工学への含意: 完全な自動検証は原理的に不可能"
      />

      <KeyPoint>
        ゲーデルの定理と停止問題は論理と計算の原理的な限界を示す。
        しかし「限界がある」ことを知ること自体が知的な進歩であり、
        限界の中で最大限の成果を上げるアプローチを導く。
        論理学は自身の限界を証明できるほど強力な体系である。
      </KeyPoint>
    </article>
    <div className="not-prose my-8">
      <StudyNotes chapterSlug="25-metalogic" />
    </div>
    </>
  )
}
