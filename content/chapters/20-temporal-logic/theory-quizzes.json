[
  {
    "id": "ch20-t1",
    "type": "multiple-choice",
    "question": "LTLの式 □(request → ◇response) の意味として正しいのは？",
    "options": [
      "すべての時点において、リクエストがあればいつか応答がある",
      "ある時点でリクエストがあり、その次に応答がある",
      "リクエストと応答は常に同時に起こる",
      "リクエストがなければ応答もない"
    ],
    "correctIndex": 0,
    "explanation": "□は「すべての時点で」、→は「ならば」、◇は「いつか」を表します。全体として「どの時点でリクエストがあっても、その後いつかは応答がある」という応答性（liveness）の仕様です。"
  },
  {
    "id": "ch20-t2",
    "type": "multiple-choice",
    "question": "LTL演算子 P U Q（PまでQ）の正確な意味は？",
    "options": [
      "将来のある時点でQが真になり、それまでの間ずっとPが真である",
      "PとQが同時に真になる",
      "Pが偽になったらQが真になる",
      "PまたはQのどちらかが常に真"
    ],
    "correctIndex": 0,
    "explanation": "P U Q（P until Q）は、Qが真になる時点が存在し（◇Qを含意）、その時点に至るまでの間PがずっとTrueであることを要求します。Qが真になることは保証されます。"
  },
  {
    "id": "ch20-t3",
    "type": "multiple-choice",
    "question": "□◇P の直感的な意味は？",
    "options": [
      "Pは無限回真になる（どの時点から見ても、将来にPが真の時点がある）",
      "Pはいつか永遠に真になる",
      "Pは次の時点で真になる",
      "Pは最初だけ真"
    ],
    "correctIndex": 0,
    "explanation": "□◇P =「常に（□）、いつか（◇）P」は、どの時点iを取っても、i以降のどこかでPが真になることを意味します。つまりPは無限に何度も真になります。これは公平性（fairness）条件としてよく使われます。"
  },
  {
    "id": "ch20-t4",
    "type": "multiple-choice",
    "question": "CTLの AG EF init の意味は？",
    "options": [
      "すべての到達可能な状態から、初期状態に戻れるパスが存在する",
      "すべてのパスで常に初期状態にいる",
      "あるパスで初期状態に戻れる",
      "次の状態が初期状態である"
    ],
    "correctIndex": 0,
    "explanation": "AG =「すべてのパスのすべての状態で」、EF =「あるパスでいつか」。AGの中にEFがあるので「すべての到達可能な状態から、initに到達できるパスが少なくとも1つ存在する」という意味です。これはリセット可能性を表します。"
  },
  {
    "id": "ch20-t5",
    "type": "gap-fill-proof",
    "steps": [
      { "id": "s1", "content": "検証する性質: 2つのプロセスが同時にクリティカルセクション(CS)に入らない", "type": "given" },
      { "id": "s2", "content": "LTLで形式化: ___", "type": "gap", "correctValue": "□¬(cs₁ ∧ cs₂)", "options": ["□¬(cs₁ ∧ cs₂)", "◇¬(cs₁ ∧ cs₂)", "□(cs₁ → cs₂)", "¬(cs₁ ∧ cs₂)"] },
      { "id": "s3", "content": "モデル検査器に入力: システムモデル M + 上記のLTL式 φ", "type": "given" },
      { "id": "s4", "content": "結果: M ⊨ φ（仕様を満たす）or 反例パス（仕様違反の実行列）", "type": "given" }
    ],
    "explanation": "「同時にCSに入らない」= 「cs₁ ∧ cs₂ は常に偽」= □¬(cs₁ ∧ cs₂)。これは安全性（safety）の典型的な仕様です。◇¬(cs₁ ∧ cs₂)は「いつか同時でない時がある」で弱すぎます。"
  }
]
