[
  {
    "id": "ch17-p1",
    "type": "multiple-choice",
    "question": "フィボナッチ数列の素朴な再帰実装 fib(n) = fib(n-1) + fib(n-2) が非効率な理由は何ですか？",
    "options": [
      "同じ値を繰り返し計算するため、指数時間の計算量になる",
      "再帰が停止しないため",
      "基底ケースが不足しているため",
      "整数オーバーフローが発生するため"
    ],
    "correctIndex": 0,
    "explanation": "fib(5) を計算するために fib(4) と fib(3) を呼び出し、fib(4) はさらに fib(3) と fib(2) を呼び出します。fib(3) が2回計算されるように、同じ値が何度も再計算されます。計算量は O(2^n) に達します。メモ化や動的計画法で O(n) に改善できます。"
  },
  {
    "id": "ch17-p2",
    "type": "multiple-choice",
    "question": "以下のプログラムのループ不変条件として適切なのはどれですか？\n\n// 配列 A の要素の合計を求める\nsum = 0; i = 0;\nwhile i < n:\n  sum = sum + A[i]\n  i = i + 1",
    "options": [
      "sum = A[0] + A[1] + ... + A[i-1]（i番目までの部分和）",
      "sum = A[i]（現在の要素の値）",
      "sum < A[n-1]（最後の要素より小さい）",
      "i = n（iがnに等しい）"
    ],
    "correctIndex": 0,
    "explanation": "ループ不変条件は「sum は A[0] から A[i-1] までの部分和である」です。初期化時 (i=0) は空の和で sum=0、各反復で A[i] を加えて i をインクリメントするので保存され、ループ終了時 (i=n) に sum が全要素の和となります。"
  },
  {
    "id": "ch17-p3",
    "type": "multiple-choice",
    "question": "再帰関数 f(n) = f(n-1) + f(n-3) (n ≧ 3) の停止性を保証するために必要な基底ケースはいくつですか？",
    "options": [
      "3つ（f(0), f(1), f(2)）",
      "1つ（f(0)のみ）",
      "2つ（f(0), f(1)）",
      "基底ケースは不要"
    ],
    "correctIndex": 0,
    "explanation": "f(n) は f(n-1) と f(n-3) に依存するため、f(3) を計算するには f(2) と f(0) が、f(4) を計算するには f(3) と f(1) が必要です。f(0), f(1), f(2) の3つの基底ケースがあれば、n ≧ 3 のすべての値が再帰的に計算できます。"
  },
  {
    "id": "ch17-p4",
    "type": "proof-builder",
    "conclusion": "∀n ≧ 0: fib(n) ≦ 2^n",
    "availablePremises": [
      { "id": "p1", "label": "基底ケース: fib(0) = 0 ≦ 1 = 2^0 ✓, fib(1) = 1 ≦ 2 = 2^1 ✓", "rule": "基底ケース" },
      { "id": "p2", "label": "強帰納仮定: k < n なるすべての k で fib(k) ≦ 2^k", "rule": "強帰納仮定" },
      { "id": "p3", "label": "fib(n) = fib(n-1) + fib(n-2) ≦ 2^(n-1) + 2^(n-2) < 2^(n-1) + 2^(n-1) = 2^n", "rule": "帰納ステップ" }
    ],
    "correctOrder": ["p1", "p2", "p3"],
    "explanation": "フィボナッチ数列は2つ前の値を参照するため、強帰納法が自然です。帰納仮定より fib(n-1) ≦ 2^(n-1) と fib(n-2) ≦ 2^(n-2) が使えます。2^(n-2) < 2^(n-1) なので、和は 2·2^(n-1) = 2^n 未満です。"
  },
  {
    "id": "ch17-p5",
    "type": "proof-builder",
    "conclusion": "二分探索は O(log n) で停止する",
    "availablePremises": [
      { "id": "p1", "label": "不変条件: target が存在するなら A[lo..hi] の範囲内にある", "rule": "ループ不変条件" },
      { "id": "p2", "label": "各反復で探索範囲が半分以下になる: hi-lo+1 → ⌊(hi-lo+1)/2⌋ 以下", "rule": "範囲の縮小" },
      { "id": "p3", "label": "探索範囲の大きさは自然数であり各ステップで厳密に減少するので、最大 ⌈log₂ n⌉ 回で lo > hi となり停止", "rule": "停止性の証明" }
    ],
    "correctOrder": ["p1", "p2", "p3"],
    "explanation": "二分探索では各反復で探索範囲が半分以下になるため、最大 log₂ n 回で探索範囲が 0 になります。ループ不変条件により結果の正当性が保証され、範囲の縮小により停止性が保証されます。"
  }
]
