import {
  Callout,
  FormulaBlock,
  ComparisonTable,
  KeyPoint,
  SectionDivider,
} from "@/components/content"

export function TheoryContent() {
  return (
    <article className="prose prose-zinc max-w-none">
      <h1>第4d章: 量化子の否定 — ド・モルガンの法則の一般化</h1>

      <h2>定義: 量化子の否定法則</h2>
      <p>
        量化子の否定には、2つの基本法則があります。
        これらは<strong>ド・モルガンの法則を量化子に一般化</strong>したものです。
      </p>

      <Callout variant="definition" label="定義">
        <p>
          <strong>法則1</strong>: ¬∀x P(x) ≡ ∃x ¬P(x)
          — 「すべてのxについてP(x)が成り立つ」の否定は、「P(x)が成り立たないxが存在する」
        </p>
        <p>
          <strong>法則2</strong>: ¬∃x P(x) ≡ ∀x ¬P(x)
          — 「P(x)が成り立つxが存在する」の否定は、「すべてのxについてP(x)が成り立たない」
        </p>
      </Callout>

      <p>
        つまり、量化子を否定すると<strong>∀と∃が入れ替わり</strong>、
        同時に<strong>述語Pも否定される</strong>のです。
        これが量化子の否定の本質です。
      </p>

      <KeyPoint>
        量化子の否定では、∀ ↔ ∃ の入れ替えと、述語Pの否定が同時に起こる。
      </KeyPoint>

      <SectionDivider />

      <h2>なぜこうなるか: ド・モルガンの法則からの自然な拡張</h2>
      <p>
        第2章で学んだド・モルガンの法則を思い出してください。
      </p>

      <FormulaBlock caption="命題論理のド・モルガンの法則">
        {"¬(A ∧ B) ≡ ¬A ∨ ¬B"}
        <br />
        {"¬(A ∨ B) ≡ ¬A ∧ ¬B"}
      </FormulaBlock>

      <p>
        ここで重要な視点があります。
        全称量化子∀は<strong>「巨大な論理積（∧）」</strong>です。
        領域の要素が a, b, c の3つだとすると、
      </p>

      <FormulaBlock caption="∀は巨大な∧">
        {"∀x P(x) ≡ P(a) ∧ P(b) ∧ P(c)"}
      </FormulaBlock>

      <p>
        「すべてのxについてP(x)」とは、「P(a)かつP(b)かつP(c)かつ...」という
        すべての要素に対する論理積に他なりません。
      </p>

      <p>
        同様に、存在量化子∃は<strong>「巨大な論理和（∨）」</strong>です。
      </p>

      <FormulaBlock caption="∃は巨大な∨">
        {"∃x P(x) ≡ P(a) ∨ P(b) ∨ P(c)"}
      </FormulaBlock>

      <p>
        「あるxについてP(x)」とは、「P(a)またはP(b)またはP(c)または...」という
        すべての要素に対する論理和です。
      </p>

      <p>
        この視点があれば、ド・モルガンの法則をそのまま適用できます。
      </p>

      <FormulaBlock caption="¬∀x P(x) の展開">
        {"¬∀x P(x)"}
        <br />
        {"= ¬(P(a) ∧ P(b) ∧ P(c))"}
        <br />
        {"= ¬P(a) ∨ ¬P(b) ∨ ¬P(c)  ← ド・モルガン"}
        <br />
        {"= ∃x ¬P(x)"}
      </FormulaBlock>

      <p>
        有限の場合だけでなく、無限の領域でもこの関係は成り立ちます。
        ド・モルガンの法則が∧と∨の間の否定の「交換」を示したように、
        量化子の否定法則は∀と∃の間の否定の「交換」を示しています。
      </p>

      <KeyPoint>
        ∀は巨大な∧、∃は巨大な∨。ド・モルガンの法則を量化子に拡張したものが量化子の否定法則である。本質は同じであり、スケールが異なるだけ。
      </KeyPoint>

      <SectionDivider />

      <h2>具体例</h2>

      <h3>ソフトウェアテスト</h3>
      <p>
        「すべてのテストが通っているわけではない」を形式化してみましょう。
      </p>

      <FormulaBlock caption="テストの部分的失敗">
        {"¬∀x Pass(x)  ≡  ∃x ¬Pass(x)"}
      </FormulaBlock>

      <p>
        CIパイプラインで「not all tests passed」というメッセージを見たとき、
        それは「少なくとも1つのテストが失敗した」ことを意味します。
        すべてのテストが失敗したわけではありません。
      </p>

      <h3>ポパーの反証主義</h3>
      <p>
        第3章で触れた反証主義を、量化子の否定で正確に定式化できます。
        「すべての白鳥は白い」を否定すると、
      </p>

      <FormulaBlock caption="反証主義の論理構造">
        {"¬∀x(Swan(x) → White(x))"}
        <br />
        {"≡ ∃x ¬(Swan(x) → White(x))"}
        <br />
        {"≡ ∃x(Swan(x) ∧ ¬White(x))  ← ¬(A→B) ≡ A∧¬B"}
      </FormulaBlock>

      <p>
        つまり「白鳥であって、白くないものが存在する」です。
        科学理論を反証するには、たった1つの反例を見つければよい。
        これがポパーの反証主義の論理的な核心であり、量化子の否定法則そのものです。
      </p>

      <h3>バグの不在証明</h3>
      <p>
        「このコードにバグは存在しない」を形式化すると、
      </p>

      <FormulaBlock caption="バグの不在">
        {"¬∃x Bug(x)  ≡  ∀x ¬Bug(x)"}
      </FormulaBlock>

      <p>
        「バグが存在しない」と「すべてのコードパスにバグがない」は同じ主張です。
        ダイクストラの有名な言葉「テストはバグの存在を示せるが、不在は示せない」は、
        ∀x ¬Bug(x) の証明がテストでは不可能であることを意味しています。
      </p>

      <KeyPoint>
        反証主義、テスト、バグ証明 — いずれも量化子の否定法則の直接的な応用である。
      </KeyPoint>

      <SectionDivider />

      <h2>最も危険な誤解: ¬∀xP(x) ≠ ∀x¬P(x)</h2>
      <p>
        量化子の否定で<strong>最も致命的な間違い</strong>は、
        ¬∀x P(x) を ∀x ¬P(x) だと思うことです。
      </p>

      <ComparisonTable
        headers={["¬∀x P(x)（正しい否定）", "∀x ¬P(x)（別の主張）"]}
        rows={[
          ["「すべてが真というわけではない」", "「すべてが偽である」"],
          ["∃x ¬P(x)（少なくとも1つが偽）", "すべてのxでP(x)が偽"],
          ["100人中1人でも偽なら真", "100人全員が偽でないと真にならない"],
        ]}
      />

      <p>
        具体例を見ましょう。
        「すべての社員がリモートワークしているわけではない」は、
      </p>

      <FormulaBlock caption="部分否定の例">
        {"¬∀x Remote(x)  ≡  ∃x ¬Remote(x)"}
      </FormulaBlock>

      <p>
        つまり「リモートワークしていない社員が少なくとも1人いる」という意味です。
        これは<strong>「すべての社員が出社している」とは全く別の主張</strong>です。
        100人の社員のうち99人がリモートで1人だけ出社していても、この命題は真になります。
      </p>

      <Callout variant="tip">
        否定の記号¬は<strong>∀の直前にある</strong>のであって、P(x)だけにかかっているのではありません。
        ¬∀は「すべてではない」であり、「すべてが否定」ではないのです。
      </Callout>

      <SectionDivider />

      <h2>どこで使われるか</h2>

      <h3>ポパーの反証主義（第3章からの接続）</h3>
      <p>
        科学的理論は「すべてのxについてP(x)」の形をとります。
        その反証は ¬∀x P(x) ≡ ∃x ¬P(x)、すなわち「反例が1つ存在すること」です。
        実験科学の方法論は、量化子の否定法則を基盤としています。
      </p>

      <h3>SQLのNOT EXISTS</h3>
      <p>
        SQLの <code>NOT EXISTS</code> は、まさにこの法則の直接的な実装です。
      </p>

      <FormulaBlock caption="NOT EXISTSの論理構造">
        {"¬∃x(InDept(x, d) ∧ ¬Active(x))"}
        <br />
        {"≡ ∀x(InDept(x, d) → Active(x))"}
      </FormulaBlock>

      <p>
        「非アクティブな社員が存在しない部署」は、
        「その部署のすべての社員がアクティブである」と同値です。
        <code>NOT EXISTS</code> サブクエリを書くとき、この等価性を理解しているかどうかで正確さが変わります。
      </p>

      <h3>バグ報告と障害対応</h3>
      <p>
        「not all tests pass（すべてのテストが通るわけではない）」と
        「all tests fail（すべてのテストが失敗する）」では、
        障害の深刻度も対応方法もまったく異なります。
      </p>

      <ComparisonTable
        headers={["not all tests pass", "all tests fail"]}
        rows={[
          ["∃x ¬Pass(x)", "∀x ¬Pass(x)"],
          ["部分的な失敗", "全面的な失敗"],
          ["個別テストの調査", "システム全体の調査"],
        ]}
      />

      <h3>法律解釈</h3>
      <p>
        法律文書における「すべてではない」の解釈は、裁判で争われることがあります。
        「すべての条件を満たしていない」が「一部の条件を満たしていない」なのか
        「すべての条件を満たしていない」なのかで、判決が変わります。
        量化子の否定法則を正しく適用できれば、この曖昧さを論理的に解消できます。
      </p>

      <KeyPoint>
        SQL、科学、法律、障害対応 — 量化子の否定法則は理論と実践の距離がゼロである。
      </KeyPoint>

      <SectionDivider />

      <h2>ないと困ること</h2>

      <h3>「not all」を「none」と誤解する</h3>
      <p>
        量化子の否定法則を知らないと、「すべてが真ではない」を「すべてが偽」と
        取り違える危険があります。
        これは日常会話でも頻繁に起こります。
      </p>
      <p>
        「全員が賛成しているわけではない」は「反対者がいる」という意味であり、
        「全員が反対している」という意味ではありません。
      </p>

      <h3>裁判での判断ミス</h3>
      <p>
        法的文書の解釈において、「すべての要件を満たしていない」の意味を
        取り違えると、契約違反の有無が正反対に判断されかねません。
        実際に裁判で「not all」の解釈が争点になった例は少なくありません。
      </p>
      <p>
        論理的な素養があれば、こうした曖昧さを構造的に分析できます。
      </p>

      <h3>ソフトウェアの障害判定を間違える</h3>
      <p>
        「not all tests pass」は少なくとも1つの失敗を意味します。
        しかし「all tests fail」はシステム全体の障害を示唆します。
      </p>
      <p>
        この区別を間違えると、部分的な問題に対してシステム全体を再起動したり、
        逆に全面障害を見逃したりする可能性があります。
        障害のトリアージには量化子の否定の正確な理解が不可欠です。
      </p>

      <SectionDivider />

      <h2>よくある誤解</h2>

      <Callout variant="warning" label="よくある誤解">
        <p>
          <strong>誤解1: 「すべてではない」=「ひとつもない」</strong>
        </p>
        <p>
          ¬∀x P(x) は ∃x ¬P(x) であり、∀x ¬P(x) ではありません。
          「すべてではない」は「少なくとも1つが偽」を意味するだけであり、
          「ひとつも真ではない」とは言っていません。
          残りの大多数が真である可能性も十分にあります。
        </p>
      </Callout>

      <Callout variant="warning" label="よくある誤解">
        <p>
          <strong>誤解2: ∀と∃は入れ替わるが、Pの否定を忘れる</strong>
        </p>
        <p>
          量化子の否定では<strong>2つの変換が同時に起こります</strong>。
          (1) ∀と∃が入れ替わる。(2) 述語Pが否定される。
        </p>
        <p>
          片方だけ適用して ¬∀x P(x) を ∃x P(x) としてしまうのはよくある間違いです。
          正しくは ∃x ¬P(x) です。¬Pを忘れないでください。
        </p>
      </Callout>

      <Callout variant="warning" label="よくある誤解">
        <p>
          <strong>誤解3: これは理論だけの話で、実用性がない</strong>
        </p>
        <p>
          SQLの <code>NOT EXISTS</code> はまさにこの法則そのものです。
          データベースのクエリを書くとき、<code>NOT EXISTS</code> サブクエリと
          <code>NOT IN</code> の使い分けには量化子の否定の理解が必要です。
        </p>
        <p>
          ポパーの反証主義、バグ報告の解釈、法律文書の分析、
          いずれも量化子の否定法則の直接的な応用です。
          理論と実践の距離はゼロです。
        </p>
      </Callout>
    </article>
  )
}
