export function TheoryContent() {
  return (
    <article className="prose prose-zinc max-w-none">
      <h1>第4a章: 述語と項 — 命題の内部構造を分析する</h1>

      <h2>定義: 述語とは何か</h2>
      <p>
        <strong>述語（predicate）</strong>とは、対象（項）を受け取って命題を返す関数のことです。
        日本語で直感的に言えば、<strong>「穴の空いた文」</strong>です。
      </p>
      <p>
        たとえば「xは人間である」という文を考えてみましょう。
        この文にはxという「穴」があり、そこに具体的な名前を入れると命題になります。
      </p>
      <ul>
        <li>x = ソクラテス → 「ソクラテスは人間である」（真の命題）</li>
        <li>x = 東京タワー → 「東京タワーは人間である」（偽の命題）</li>
        <li>x = 3 → 「3は人間である」（偽の命題）</li>
      </ul>
      <p>
        穴を埋める前は命題ではなく、真偽が定まりません。
        穴を埋めた瞬間に、真か偽のいずれかの値を持つ命題になります。
        この「穴の空いた文」を述語と呼び、穴に入る具体的な対象を<strong>項（term）</strong>と呼びます。
      </p>
      <p>
        形式的に書くと、述語は <code>H(x)</code> のように表記します。
        Hが述語名、xが項（変数または定数）です。
        <code>H(ソクラテス)</code> と書けば「ソクラテスは人間である」という命題になります。
      </p>

      <h2>アリティ（引数の数）</h2>
      <p>
        述語は「穴」の数によって分類されます。穴の数を<strong>アリティ（arity）</strong>と呼びます。
      </p>

      <h3>一項述語（1-place predicate）</h3>
      <p>
        穴が1つの述語です。対象の性質を表します。
      </p>
      <ul>
        <li><code>H(x)</code>: xは人間である</li>
        <li><code>E(x)</code>: xは偶数である</li>
        <li><code>P(x)</code>: xは素数である</li>
        <li><code>A(x)</code>: xはアクティブなユーザーである</li>
      </ul>

      <h3>二項述語（2-place predicate）</h3>
      <p>
        穴が2つの述語です。2つの対象の間の関係を表します。
      </p>
      <ul>
        <li><code>G(x, y)</code>: xはyより大きい</li>
        <li><code>L(x, y)</code>: xはyを愛している</li>
        <li><code>F(x, y)</code>: xはyの友人である</li>
        <li><code>O(x, y)</code>: xはyを所有している</li>
      </ul>
      <p>
        二項述語では引数の順序が重要です。
        「太郎は花子を愛している」と「花子は太郎を愛している」は異なる命題です。
        <code>L(太郎, 花子)</code> と <code>L(花子, 太郎)</code> は別物です。
      </p>

      <h3>三項述語（3-place predicate）</h3>
      <p>
        穴が3つの述語です。3つの対象の間の複雑な関係を表します。
      </p>
      <ul>
        <li><code>S(x, y, z)</code>: xはyにzを送った</li>
        <li><code>B(x, y, z)</code>: xはyとzの間にある</li>
        <li><code>I(x, y, z)</code>: xはyにzを紹介した</li>
      </ul>
      <p>
        理論上はアリティに上限はありませんが、
        実用上は一項から三項が圧倒的に多く使われます。
      </p>

      <h2>具体例: なぜ命題論理だけでは不十分なのか</h2>

      <h3>ソクラテスの三段論法</h3>
      <p>
        古典的な推論を見てみましょう。
      </p>
      <ul>
        <li>前提1: すべての人間は死すべきものである</li>
        <li>前提2: ソクラテスは人間である</li>
        <li>結論: ソクラテスは死すべきものである</li>
      </ul>
      <p>
        命題論理では、これをP、Q、Rという3つの独立した命題としか扱えません。
        P ∧ Q → R が成り立つかどうかは、真理値表で確認するしかなく、
        推論の<strong>構造的な必然性</strong>を捉えることができません。
      </p>
      <p>
        述語論理では、こう分析できます。
      </p>
      <ul>
        <li>前提1: すべてのxについて、H(x) → M(x)（人間なら死すべき）</li>
        <li>前提2: H(ソクラテス)（ソクラテスは人間）</li>
        <li>結論: M(ソクラテス)（ソクラテスは死すべき）</li>
      </ul>
      <p>
        命題の内部構造を分析することで、推論がなぜ正しいのかを形式的に説明できます。
      </p>

      <h3>SQLのWHERE句</h3>
      <p>
        SQLを書いたことがあるなら、すでに述語を使っています。
      </p>
      <p>
        <code>SELECT * FROM users WHERE age &gt; 20 AND is_active = true</code>
      </p>
      <p>
        このWHERE句は述語そのものです。
      </p>
      <ul>
        <li><code>age &gt; 20</code> は一項述語「xの年齢は20より大きい」</li>
        <li><code>is_active = true</code> は一項述語「xはアクティブである」</li>
        <li><code>AND</code> は論理積（第1章で学んだ結合子）</li>
      </ul>
      <p>
        WHERE句とは「この述語を満たす行（=項）をすべて返せ」という指示です。
        これは後の章で学ぶ「存在量化」と深く関わります。
      </p>

      <h3>TypeScriptの型ガード</h3>
      <p>
        TypeScriptの型ガード関数は、まさに述語のプログラミング的実装です。
      </p>
      <p>
        <code>function isString(x: unknown): x is string</code>
      </p>
      <p>
        この関数は「xはstring型である」という一項述語です。
        TypeScriptでは戻り値の型を <code>x is string</code> と書くことで、
        コンパイラに「この関数が真を返したら、xはstringとして扱ってよい」と伝えます。
        論理学の述語とプログラミングの型ガードは同じ構造を持っています。
      </p>

      <h3>法律の契約書</h3>
      <p>
        法律文書も述語で構造化されています。
      </p>
      <ul>
        <li>「甲は乙に対して、月額10万円を支払う」→ <code>Pay(甲, 乙, 10万円)</code>（三項述語）</li>
        <li>「本契約は日本法に準拠する」→ <code>GoverningLaw(本契約, 日本法)</code>（二項述語）</li>
        <li>「甲が本条項に違反した場合」→ <code>Violate(甲, 本条項)</code>（二項述語）</li>
      </ul>
      <p>
        契約書の各条項は述語と項で構成されており、
        「誰が」「何に対して」「何をする」という構造を明確にしています。
      </p>

      <h2>成り立たない例: 述語でないもの</h2>
      <p>
        述語の定義を正確に理解するために、述語に見えるが述語でないものを確認しましょう。
      </p>

      <h3>「おはよう」は述語ではない</h3>
      <p>
        挨拶や感嘆は、穴にどんな対象を入れても命題になりません。
        そもそも穴がなく、真偽を問える文を生成する機能を持っていません。
      </p>

      <h3>「x + 3」は述語ではない（しかし「x + 3 = 7」は述語である）</h3>
      <p>
        <code>x + 3</code> は数式であり、計算結果は数値です。真偽を返しません。
        これは<strong>関数（項を返すもの）</strong>であって述語ではありません。
        一方、<code>x + 3 = 7</code> は「xに4を入れると真、それ以外は偽」になる立派な述語です。
        述語と関数の違いは「返り値が命題（真偽値）かどうか」です。
      </p>

      <h3>「雨が降っている」は命題であって述語ではない</h3>
      <p>
        「雨が降っている」には穴がありません。すでに完全な文であり、真か偽が定まっています。
        これは命題（0項述語と見なすこともできますが、通常は命題と呼びます）です。
        述語は穴が空いている状態、命題は穴が埋まっている状態です。
      </p>

      <h2>どこで使われるか</h2>
      <p>
        述語は抽象的な概念に見えますが、日常的なツールの根底にある仕組みです。
      </p>

      <h3>SQL（関係データベース）</h3>
      <ul>
        <li><code>WHERE</code> 句 = 一項述語（行に対するフィルタ条件）</li>
        <li><code>JOIN ON</code> 句 = 二項述語（2つのテーブルの行の関係）</li>
        <li><code>HAVING</code> 句 = 集約結果に対する述語</li>
        <li><code>CHECK</code> 制約 = テーブル定義に埋め込まれた述語</li>
      </ul>
      <p>
        関係代数（relational algebra）は述語論理を基盤として構築されています。
        SQLを理解することは、述語論理を実践的に使うことに他なりません。
      </p>

      <h3>TypeScript / プログラミング言語</h3>
      <ul>
        <li>型ガード（<code>x is Type</code>）= 一項述語</li>
        <li><code>Array.filter(predicate)</code> = 述語でフィルタリング</li>
        <li><code>Array.every(predicate)</code> = 全称量化（すべてのxについて述語が真）</li>
        <li><code>Array.some(predicate)</code> = 存在量化（あるxについて述語が真）</li>
      </ul>

      <h3>法律文書</h3>
      <ul>
        <li>契約条項の主語・目的語・述部 = 項と述語</li>
        <li>「すべての当事者は〜する義務を負う」= 全称量化 + 述語</li>
        <li>「いずれかの当事者が違反した場合」= 存在量化 + 述語</li>
      </ul>

      <h3>データベース設計</h3>
      <ul>
        <li>テーブルのカラム = 一項述語（エンティティの属性）</li>
        <li>外部キー = 二項述語（エンティティ間の関係）</li>
        <li>中間テーブル = 多項述語（多対多の関係）</li>
      </ul>

      <h2>ないと困ること</h2>
      <p>
        述語の概念がなければ、以下のことが不可能または極めて困難になります。
      </p>

      <h3>「すべて」と「ある」の区別ができない</h3>
      <p>
        命題論理では「すべての顧客が満足している」と「ある顧客が満足している」を
        区別する方法がありません。どちらも単に命題Pとしか書けません。
        述語論理では、述語 <code>S(x)</code>（xは満足している）を定義し、
        「すべてのxについてS(x)」と「あるxについてS(x)」を明確に区別できます。
      </p>

      <h3>SQLが呪文になる</h3>
      <p>
        述語の概念を知らずにSQLを書くと、WHERE句やJOIN ONの意味が不透明になります。
        「なぜこの条件で正しいデータが返るのか」を論理的に説明できず、
        パターンの丸暗記に頼るしかありません。
        述語を理解すれば、SQLの各句が何を主張しているかを正確に把握できます。
      </p>

      <h3>型ガードの設計ができない</h3>
      <p>
        TypeScriptで安全な型絞り込みを行うには、型ガード関数を適切に設計する必要があります。
        述語の概念を理解していれば、「この関数はどんな性質を判定すべきか」を
        明確に定義し、正確な型ガードを書けます。
      </p>

      <h3>契約書の曖昧さを見抜けない</h3>
      <p>
        「甲は責任を負う」という文は、述語の観点から見ると項（主語・目的語）が不足しています。
        「誰に対して」「何について」の責任なのか。述語の構造を意識すれば、
        契約書の曖昧な条項を見抜けるようになります。
      </p>

      <h2>よくある誤解</h2>

      <h3>誤解1: 述語 = 動詞</h3>
      <p>
        日本語文法の「述語」は動詞や形容詞を指しますが、
        論理学の述語はそれよりずっと広い概念です。
      </p>
      <ul>
        <li>「xは偶数である」— 数学的性質（動詞ではない）</li>
        <li>「xはyより大きい」— 大小関係（動詞ではない）</li>
        <li>「xはアクティブユーザーである」— 状態（動詞ではない）</li>
      </ul>
      <p>
        論理学の述語は「対象を受け取って真偽を返すもの」であり、
        言語学的な品詞の区分とは独立した概念です。
      </p>

      <h3>誤解2: 述語は引数を1つしか取れない</h3>
      <p>
        一項述語が最もシンプルなので目立ちますが、
        二項述語 <code>G(x, y)</code> や三項述語 <code>S(x, y, z)</code> も等しく重要です。
        とくにデータベースの外部キー（二項述語）や
        送金処理 <code>Transfer(送信者, 受信者, 金額)</code>（三項述語）など、
        実務では多項述語が頻繁に登場します。
      </p>

      <h3>誤解3: 述語論理は命題論理と無関係</h3>
      <p>
        述語論理は命題論理を<strong>拡張</strong>したものです。
        第1章〜第3章で学んだ論理結合子（∧, ∨, →, ¬）はすべて述語論理でも使います。
        命題論理の知識は述語論理の土台であり、無駄にはなりません。
        述語論理は命題論理に「対象」と「述語」と「量化子」を追加したものと考えてください。
      </p>
    </article>
  )
}
