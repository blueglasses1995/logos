[
  {
    "id": "ch4b-t1",
    "type": "multiple-choice",
    "question": "「すべての社員は研修を受講済みである」を述語論理で正しく形式化したものはどれですか？\n\nE(x): xは社員である\nT(x): xは研修を受講済みである",
    "options": [
      "∀x (E(x) → T(x))",
      "∀x (E(x) ∧ T(x))",
      "∃x (E(x) → T(x))",
      "∀x (T(x) → E(x))"
    ],
    "correctIndex": 0,
    "explanation": "∀x (E(x) → T(x)) は「すべてのxについて、xが社員ならば研修受講済みである」という意味で正しい形式化です。∀x (E(x) ∧ T(x)) は「宇宙のすべてのものが社員であり研修受講済み」という荒唐無稽な主張になります。∧ではなく → を使うことで、「社員であるもの」に限定して主張できます。"
  },
  {
    "id": "ch4b-t2",
    "type": "multiple-choice",
    "question": "∀x (S(x) ∧ P(x)) と ∀x (S(x) → P(x)) の違いについて、正しい説明はどれですか？",
    "options": [
      "∧ を使うと「宇宙のすべてのものがS(x)かつP(x)」という意味になり、ほぼ必ず偽になる。→ を使えば「S(x)であるものに限ってP(x)が成り立つ」という適切な限定になる",
      "∧ と → は全称量化子と組み合わせた場合は同じ意味になる",
      "→ を使うと「S(x)であるものの中で一部がP(x)」という意味になり、∧ の方がより正確である",
      "∧ の方が「すべて」を正確に表現でき、→ は「もし〜ならば」なので全称量化には不適切である"
    ],
    "correctIndex": 0,
    "explanation": "∀x (S(x) ∧ P(x)) は対象領域のすべてのxがS(x)でありP(x)であることを主張します。たとえばS(x)が「xは学生」、P(x)が「xは合格した」のとき、机も犬も太陽もすべてが「学生であり合格した」ことになります。∀x (S(x) → P(x)) なら、学生でないものについてはS(x)が偽なので → は自動的に真（空真）となり、実質的に「学生であるもの全員が合格した」という意味になります。"
  },
  {
    "id": "ch4b-t3",
    "type": "multiple-choice",
    "question": "¬∀x P(x) を同値な表現に書き換えるとどうなりますか？",
    "options": [
      "∃x ¬P(x)（P(x)が成り立たないxが少なくとも1つ存在する）",
      "∀x ¬P(x)（すべてのxについてP(x)が成り立たない）",
      "¬∃x P(x)（P(x)が成り立つxは1つも存在しない）",
      "∃x P(x)（P(x)が成り立つxが少なくとも1つ存在する）"
    ],
    "correctIndex": 0,
    "explanation": "¬∀x P(x)（すべてのxについてP(x)が成り立つわけではない）は、∃x ¬P(x)（P(x)が成り立たないxが少なくとも1つ存在する）と同値です。「全員が賛成しているわけではない」は「少なくとも1人の反対者がいる」と同じ意味です。∀x ¬P(x)は「全員が反対」という別のはるかに強い主張であり、¬∀x P(x) とは異なります。"
  },
  {
    "id": "ch4b-t4",
    "type": "multiple-choice",
    "question": "プログラミングにおいて、∀x P(x)（すべてのxについてP(x)が成り立つ）に最も直接的に対応するのはどれですか？",
    "options": [
      "array.every(x => P(x)) — 配列のすべての要素がPを満たすか検証する",
      "array.some(x => P(x)) — 配列のいずれかの要素がPを満たすか検証する",
      "array.filter(x => P(x)) — Pを満たす要素だけを取り出す",
      "array.find(x => P(x)) — Pを満たす最初の要素を返す"
    ],
    "correctIndex": 0,
    "explanation": "array.every() は配列のすべての要素について述語関数が真を返すかを検証します。1つでも偽を返す要素があれば全体として false を返します。これは ∀x P(x) の直接的な実装です。array.some() は存在量化子（∃）に対応し、「少なくとも1つ」の要素がPを満たせば true を返します。filter や find は量化子というより述語によるフィルタリングです。"
  },
  {
    "id": "ch4b-t5",
    "type": "multiple-choice",
    "question": "1697年にオーストラリアで黒い白鳥が発見される前、ヨーロッパでは「∀x (Swan(x) → White(x))」（すべての白鳥は白い）が真と信じられていました。黒い白鳥の発見がこの命題に与えた影響について、正しいのはどれですか？",
    "options": [
      "たった一羽の反例（黒い白鳥）により、∀x (Swan(x) → White(x)) は偽であることが確定した",
      "一羽だけでは統計的に有意ではないため、∀x (Swan(x) → White(x)) は依然として真である",
      "黒い白鳥の発見により、∀x (Swan(x) → ¬White(x))（すべての白鳥は白くない）が証明された",
      "∀x (Swan(x) → White(x)) は数学的定理であるため、経験的な反例では覆せない"
    ],
    "correctIndex": 0,
    "explanation": "∀x P(x) はすべてのxについてP(x)が真であることを主張するため、たった1つの反例で偽になります。統計的有意性は関係ありません。また、∀x (Swan(x) → White(x)) が偽であることは ∃x (Swan(x) ∧ ¬White(x))（白くない白鳥が存在する）を意味するだけであり、∀x (Swan(x) → ¬White(x))（すべての白鳥が白くない）を意味するわけではありません。なお、これは経験的主張であり数学的定理ではないため、経験的反例で覆ります。"
  }
]
